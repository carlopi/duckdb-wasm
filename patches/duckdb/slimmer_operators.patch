diff --git a/src/common/vector_operations/boolean_operators.cpp b/src/common/vector_operations/boolean_operators.cpp
index 667c920858..718ba193bf 100644
--- a/src/common/vector_operations/boolean_operators.cpp
+++ b/src/common/vector_operations/boolean_operators.cpp
@@ -39,7 +39,8 @@ static void TemplatedBooleanNullmask(Vector &left, Vector &right, Vector &result
 		auto right_data = UnifiedVectorFormat::GetData<uint8_t>(rdata);
 		auto result_data = FlatVector::GetData<bool>(result);
 		auto &result_mask = FlatVector::Validity(result);
-		if (!ldata.validity.AllValid() || !rdata.validity.AllValid()) {
+	//	if (!ldata.validity.AllValid() || !rdata.validity.AllValid()) {
+		{
 			for (idx_t i = 0; i < count; i++) {
 				auto lidx = ldata.sel->get_index(i);
 				auto ridx = rdata.sel->get_index(i);
@@ -48,12 +49,12 @@ static void TemplatedBooleanNullmask(Vector &left, Vector &right, Vector &result
 				                  !rdata.validity.RowIsValid(ridx), result_data[i]);
 				result_mask.Set(i, !is_null);
 			}
-		} else {
-			for (idx_t i = 0; i < count; i++) {
-				auto lidx = ldata.sel->get_index(i);
-				auto ridx = rdata.sel->get_index(i);
-				result_data[i] = OP::SimpleOperation(left_data[lidx], right_data[ridx]);
-			}
+//		} else {
+//			for (idx_t i = 0; i < count; i++) {
+//				auto lidx = ldata.sel->get_index(i);
+//				auto ridx = rdata.sel->get_index(i);
+//				result_data[i] = OP::SimpleOperation(left_data[lidx], right_data[ridx]);
+//			}
 		}
 	}
 }
diff --git a/src/common/vector_operations/is_distinct_from.cpp b/src/common/vector_operations/is_distinct_from.cpp
index e9a31ee0e6..900ea95306 100644
--- a/src/common/vector_operations/is_distinct_from.cpp
+++ b/src/common/vector_operations/is_distinct_from.cpp
@@ -129,13 +129,13 @@ DistinctSelectGenericLoopSwitch(const LEFT_TYPE *__restrict ldata, const RIGHT_T
                                 const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
                                 const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
                                 ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
-	if (!lmask.AllValid() || !rmask.AllValid()) {
+//	if (!lmask.AllValid() || !rmask.AllValid()) {
 		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, false>(
 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
-	} else {
-		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, true>(
-		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
-	}
+//	} else {
+//		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, true>(
+//		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
+//	}
 }
 
 template <class LEFT_TYPE, class RIGHT_TYPE, class OP>
diff --git a/src/include/duckdb/common/vector_operations/binary_executor.hpp b/src/include/duckdb/common/vector_operations/binary_executor.hpp
index 55c10bb289..936c2b42b0 100644
--- a/src/include/duckdb/common/vector_operations/binary_executor.hpp
+++ b/src/include/duckdb/common/vector_operations/binary_executor.hpp
@@ -79,13 +79,13 @@ struct BinaryExecutor {
 			ASSERT_RESTRICT(rdata, rdata + count, result_data, result_data + count);
 		}
 
-		if (!mask.AllValid()) {
+		if (true) {
 			idx_t base_idx = 0;
 			auto entry_count = ValidityMask::EntryCount(count);
 			for (idx_t entry_idx = 0; entry_idx < entry_count; entry_idx++) {
 				auto validity_entry = mask.GetValidityEntry(entry_idx);
 				idx_t next = MinValue<idx_t>(base_idx + ValidityMask::BITS_PER_VALUE, count);
-				if (ValidityMask::AllValid(validity_entry)) {
+/*				if (ValidityMask::AllValid(validity_entry)) {
 					// all valid: perform operation
 					for (; base_idx < next; base_idx++) {
 						auto lentry = ldata[LEFT_CONSTANT ? 0 : base_idx];
@@ -99,6 +99,8 @@ struct BinaryExecutor {
 					base_idx = next;
 					continue;
 				} else {
+*/
+{
 					// partially valid: need to check individual elements for validity
 					idx_t start = base_idx;
 					for (; base_idx < next; base_idx++) {
@@ -112,13 +114,6 @@ struct BinaryExecutor {
 					}
 				}
 			}
-		} else {
-			for (idx_t i = 0; i < count; i++) {
-				auto lentry = ldata[LEFT_CONSTANT ? 0 : i];
-				auto rentry = rdata[RIGHT_CONSTANT ? 0 : i];
-				result_data[i] = OPWRAPPER::template Operation<FUNC, OP, LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE>(
-				    fun, lentry, rentry, mask, i);
-			}
 		}
 	}
 
@@ -188,7 +183,8 @@ struct BinaryExecutor {
 	                               RESULT_TYPE *__restrict result_data, const SelectionVector *__restrict lsel,
 	                               const SelectionVector *__restrict rsel, idx_t count, ValidityMask &lvalidity,
 	                               ValidityMask &rvalidity, ValidityMask &result_validity, FUNC fun) {
-		if (!lvalidity.AllValid() || !rvalidity.AllValid()) {
+//		if (!lvalidity.AllValid() || !rvalidity.AllValid()) {
+		{
 			for (idx_t i = 0; i < count; i++) {
 				auto lindex = lsel->get_index(i);
 				auto rindex = rsel->get_index(i);
@@ -201,13 +197,14 @@ struct BinaryExecutor {
 					result_validity.SetInvalid(i);
 				}
 			}
-		} else {
+/*		} else {
 			for (idx_t i = 0; i < count; i++) {
 				auto lentry = ldata[lsel->get_index(i)];
 				auto rentry = rdata[rsel->get_index(i)];
 				result_data[i] = OPWRAPPER::template Operation<FUNC, OP, LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE>(
 				    fun, lentry, rentry, result_validity, i);
 			}
+*/
 		}
 	}
 
diff --git a/src/include/duckdb/common/vector_operations/unary_executor.hpp b/src/include/duckdb/common/vector_operations/unary_executor.hpp
index 9f29d7410f..e565ad7b51 100644
--- a/src/include/duckdb/common/vector_operations/unary_executor.hpp
+++ b/src/include/duckdb/common/vector_operations/unary_executor.hpp
@@ -71,7 +71,7 @@ private:
 		ASSERT_RESTRICT(ldata, ldata + max_index, result_data, result_data + count);
 #endif
 
-		if (!mask.AllValid()) {
+		if (true) {
 			for (idx_t i = 0; i < count; i++) {
 				auto idx = sel_vector->get_index(i);
 				if (mask.RowIsValidUnsafe(idx)) {
@@ -81,12 +81,6 @@ private:
 					result_mask.SetInvalid(i);
 				}
 			}
-		} else {
-			for (idx_t i = 0; i < count; i++) {
-				auto idx = sel_vector->get_index(i);
-				result_data[i] =
-				    OPWRAPPER::template Operation<OP, INPUT_TYPE, RESULT_TYPE>(ldata[idx], result_mask, i, dataptr);
-			}
 		}
 	}
 
@@ -95,7 +89,7 @@ private:
 	                               ValidityMask &mask, ValidityMask &result_mask, void *dataptr, bool adds_nulls) {
 		ASSERT_RESTRICT(ldata, ldata + count, result_data, result_data + count);
 
-		if (!mask.AllValid()) {
+		if (true) {
 			if (!adds_nulls) {
 				result_mask.Initialize(mask);
 			} else {
@@ -106,6 +100,7 @@ private:
 			for (idx_t entry_idx = 0; entry_idx < entry_count; entry_idx++) {
 				auto validity_entry = mask.GetValidityEntry(entry_idx);
 				idx_t next = MinValue<idx_t>(base_idx + ValidityMask::BITS_PER_VALUE, count);
+				/*
 				if (ValidityMask::AllValid(validity_entry)) {
 					// all valid: perform operation
 					for (; base_idx < next; base_idx++) {
@@ -116,7 +111,7 @@ private:
 					// nothing valid: skip all
 					base_idx = next;
 					continue;
-				} else {
+				} else */ {
 					// partially valid: need to check individual elements for validity
 					idx_t start = base_idx;
 					for (; base_idx < next; base_idx++) {
@@ -128,11 +123,6 @@ private:
 					}
 				}
 			}
-		} else {
-			for (idx_t i = 0; i < count; i++) {
-				result_data[i] =
-				    OPWRAPPER::template Operation<OP, INPUT_TYPE, RESULT_TYPE>(ldata[i], result_mask, i, dataptr);
-			}
 		}
 	}
 

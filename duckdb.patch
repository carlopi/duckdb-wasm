diff --git a/extension/extension_config.cmake b/extension/extension_config.cmake
index 8990ddc4bc..02b3485c1c 100644
--- a/extension/extension_config.cmake
+++ b/extension/extension_config.cmake
@@ -1,17 +1,17 @@
 ################################################################################
-# DuckDB extension base config
+# DuckDB-Wasm extension base config
 ################################################################################
 #
-# This is the base DuckDB extension configuration file. The extensions loaded here are included in every DuckDB build.
-# Note that this file is checked into version control; if you want to specify which extensions to load for local
-# development, create `extension/extension_config_local.cmake` and specify extensions there.
-# The local file is also loaded by the DuckDB CMake build but ignored by version control.
+duckdb_extension_load(json DONT_LINK)
+duckdb_extension_load(parquet DONT_LINK)
+duckdb_extension_load(autocomplete DONT_LINK)
 
-# Parquet is loaded by default on every build as its a essential part of DuckDB
-duckdb_extension_load(parquet)
+duckdb_extension_load(excel DONT_LINK)
+duckdb_extension_load(fts DONT_LINK)
+duckdb_extension_load(inet DONT_LINK)
+duckdb_extension_load(icu DONT_LINK)
+duckdb_extension_load(sqlsmith DONT_LINK)
+duckdb_extension_load(tpcds DONT_LINK)
+duckdb_extension_load(tpch DONT_LINK)
 
-# The Linux allocator has issues so we use jemalloc, but only on x86 because page sizes are fixed at 4KB.
-# If page sizes vary for an architecture (e.g., arm64), we cannot create a portable binary due to jemalloc config
-if(OS_NAME STREQUAL "linux" AND (OS_ARCH STREQUAL "amd64" OR OS_ARCH STREQUAL "i386") AND NOT WASM_LOADABLE_EXTENSIONS AND NOT CLANG_TIDY AND NOT ANDROID AND NOT ZOS)
-    duckdb_extension_load(jemalloc)
-endif()
+#duckdb_extension_load(httpfs DONT_LINK)
diff --git a/scripts/test_docker_images.sh b/scripts/test_docker_images.sh
index c805ce897e..c43bc6c27e 100755
--- a/scripts/test_docker_images.sh
+++ b/scripts/test_docker_images.sh
@@ -8,6 +8,7 @@ make clean
 # Currently not working due to cmake version being too low
 # docker run -i --rm -v $(pwd):/duckdb --workdir /duckdb amazonlinux:2 <<< "yum install gcc gcc-c++ git make cmake ninja-build -y && GEN=ninja make && $TEST" 2>&1
 
+docker run -i --rm -v $(pwd):/duckdb --workdir /duckdb alpine:latest <<< "apk add g++ git make cmake ninja python3 && cmake -Bbuild_folder . && cmake --build build_folder && cmake --install build_folder && g++ -std=c++11 examples/embedded-c++/main.cpp"
 docker run -i --rm -v $(pwd):/duckdb --workdir /duckdb amazonlinux:latest <<< "yum install clang git make cmake ninja-build -y && GEN=ninja make && $TEST" 2>&1
 docker run -i --platform linux/arm64 --rm -v $(pwd):/duckdb --workdir /duckdb alpine:latest <<< "apk add g++ git make cmake ninja && GEN=ninja make && $TEST" 2>&1
 docker run -i --platform linux/amd64 --rm -v $(pwd):/duckdb --workdir /duckdb alpine:latest <<< "apk add g++ git make cmake ninja && GEN=ninja make && $TEST" 2>&1
diff --git a/src/common/file_system.cpp b/src/common/file_system.cpp
index 27160adc3f..ec0c5de37c 100644
--- a/src/common/file_system.cpp
+++ b/src/common/file_system.cpp
@@ -317,6 +317,7 @@ string FileSystem::ExtractBaseName(const string &path) {
 }
 
 string FileSystem::GetHomeDirectory(optional_ptr<FileOpener> opener) {
+	std::cout << "GetHomeDirectory with opener\n";
 	// read the home_directory setting first, if it is set
 	if (opener) {
 		Value result;
@@ -335,10 +336,12 @@ string FileSystem::GetHomeDirectory(optional_ptr<FileOpener> opener) {
 }
 
 string FileSystem::GetHomeDirectory() {
+	std::cout << "GetHomeDirectory\n";
 	return GetHomeDirectory(nullptr);
 }
 
 string FileSystem::ExpandPath(const string &path, optional_ptr<FileOpener> opener) {
+	std::cout << "ExpandPath\n";
 	if (path.empty()) {
 		return path;
 	}
diff --git a/src/include/duckdb/common/enable_shared_from_this.ipp b/src/include/duckdb/common/enable_shared_from_this_ipp.hpp
similarity index 100%
rename from src/include/duckdb/common/enable_shared_from_this.ipp
rename to src/include/duckdb/common/enable_shared_from_this_ipp.hpp
diff --git a/src/include/duckdb/common/file_open_flags.hpp b/src/include/duckdb/common/file_open_flags.hpp
index d0509a214b..f1689b2975 100644
--- a/src/include/duckdb/common/file_open_flags.hpp
+++ b/src/include/duckdb/common/file_open_flags.hpp
@@ -100,8 +100,8 @@ public:
 		return flags & FILE_FLAGS_PARALLEL_ACCESS;
 	}
 
-private:
 	idx_t flags = 0;
+private:
 	FileLockType lock = FileLockType::NO_LOCK;
 	FileCompressionType compression = FileCompressionType::UNCOMPRESSED;
 };
diff --git a/src/include/duckdb/common/shared_ptr.hpp b/src/include/duckdb/common/shared_ptr.hpp
index 6d0910ca6b..eff60e3db2 100644
--- a/src/include/duckdb/common/shared_ptr.hpp
+++ b/src/include/duckdb/common/shared_ptr.hpp
@@ -37,9 +37,9 @@ struct compatible_with_t : std::is_convertible<U *, T *> {}; // NOLINT: invalid
 
 } // namespace duckdb
 
-#include "duckdb/common/shared_ptr.ipp"
-#include "duckdb/common/weak_ptr.ipp"
-#include "duckdb/common/enable_shared_from_this.ipp"
+#include "duckdb/common/shared_ptr_ipp.hpp"
+#include "duckdb/common/weak_ptr_ipp.hpp"
+#include "duckdb/common/enable_shared_from_this_ipp.hpp"
 
 namespace duckdb {
 
diff --git a/src/include/duckdb/common/shared_ptr.ipp b/src/include/duckdb/common/shared_ptr_ipp.hpp
similarity index 100%
rename from src/include/duckdb/common/shared_ptr.ipp
rename to src/include/duckdb/common/shared_ptr_ipp.hpp
diff --git a/src/include/duckdb/common/weak_ptr.ipp b/src/include/duckdb/common/weak_ptr_ipp.hpp
similarity index 100%
rename from src/include/duckdb/common/weak_ptr.ipp
rename to src/include/duckdb/common/weak_ptr_ipp.hpp
diff --git a/src/include/duckdb/main/extension_install_info.hpp b/src/include/duckdb/main/extension_install_info.hpp
index 64b7b520a7..b03f64b3aa 100644
--- a/src/include/duckdb/main/extension_install_info.hpp
+++ b/src/include/duckdb/main/extension_install_info.hpp
@@ -49,9 +49,9 @@ public:
 
 struct ExtensionRepository {
 	//! All currently available repositories
-	static constexpr const char *CORE_REPOSITORY_URL = "http://extensions.duckdb.org";
-	static constexpr const char *CORE_NIGHTLY_REPOSITORY_URL = "http://nightly-extensions.duckdb.org";
-	static constexpr const char *COMMUNITY_REPOSITORY_URL = "http://community-extensions.duckdb.org";
+	static constexpr const char *CORE_REPOSITORY_URL = "https://extensions.duckdb.org";
+	static constexpr const char *CORE_NIGHTLY_REPOSITORY_URL = "https://nightly-extensions.duckdb.org";
+	static constexpr const char *COMMUNITY_REPOSITORY_URL = "https://community-extensions.duckdb.org";
 
 	//! Debugging repositories (target local, relative paths that are produced by DuckDB's build system)
 	static constexpr const char *BUILD_DEBUG_REPOSITORY_PATH = "./build/debug/repository";
diff --git a/src/main/extension/extension_helper.cpp b/src/main/extension/extension_helper.cpp
index 3954e232b7..9679e18d05 100644
--- a/src/main/extension/extension_helper.cpp
+++ b/src/main/extension/extension_helper.cpp
@@ -304,7 +304,6 @@ vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(DatabaseInstance
 
 	auto &config = DBConfig::GetConfig(db);
 
-#ifndef WASM_LOADABLE_EXTENSIONS
 	case_insensitive_set_t seen_extensions;
 
 	// scan the install directory for installed extensions
@@ -321,7 +320,6 @@ vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(DatabaseInstance
 
 		result.push_back(UpdateExtensionInternal(db, fs, fs.JoinPath(ext_directory, path), extension_name));
 	});
-#endif
 
 	for (const auto &extension : db.LoadedExtensions()) {
 		if (seen_extensions.find(extension) != seen_extensions.end()) {
diff --git a/src/main/extension/extension_install.cpp b/src/main/extension/extension_install.cpp
index d188cb5dc3..d323fe9d7a 100644
--- a/src/main/extension/extension_install.cpp
+++ b/src/main/extension/extension_install.cpp
@@ -194,7 +194,7 @@ string ExtensionHelper::ExtensionUrlTemplate(optional_ptr<const DBConfig> db_con
 		versioned_path = "/${REVISION}/${PLATFORM}/${NAME}.duckdb_extension";
 	}
 #ifdef WASM_LOADABLE_EXTENSIONS
-	string default_endpoint = DEFAULT_REPOSITORY;
+	string default_endpoint = ExtensionRepository::DEFAULT_REPOSITORY_URL;
 	versioned_path = versioned_path + ".wasm";
 #else
 	string default_endpoint = ExtensionRepository::DEFAULT_REPOSITORY_URL;
diff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp
index 65438aa8ec..57f390cb5b 100644
--- a/src/main/extension/extension_load.cpp
+++ b/src/main/extension/extension_load.cpp
@@ -175,15 +175,18 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		direct_load = false;
 		string extension_name = ApplyExtensionAlias(extension);
 #ifdef WASM_LOADABLE_EXTENSIONS
-		string url_template = ExtensionUrlTemplate(&config, "");
+		ExtensionRepository repository;
+		string url_template = ExtensionUrlTemplate(&config, repository, "");
 		string url = ExtensionFinalizeUrlTemplate(url_template, extension_name);
 
 		char *str = (char *)EM_ASM_PTR(
 		    {
+			console.log("ASDASDASDAS");
 			    var jsString = ((typeof runtime == 'object') && runtime && (typeof runtime.whereToLoad == 'function') &&
 			                    runtime.whereToLoad)
 			                       ? runtime.whereToLoad(UTF8ToString($0))
 			                       : (UTF8ToString($1));
+			console.log("ASDASDASDAS");
 			    var lengthBytes = lengthBytesUTF8(jsString) + 1;
 			    // 'jsString.length' would return the length of the string as UTF-16
 			    // units, but Emscripten C strings operate as UTF-8.
@@ -215,7 +218,7 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		direct_load = true;
 		filename = fs.ExpandPath(filename);
 	}
-	if (!fs.FileExists(filename)) {
+/*	if (!fs.FileExists(filename)) {
 		string message;
 		bool exact_match = ExtensionHelper::CreateSuggestions(extension, message);
 		if (exact_match) {
@@ -224,8 +227,9 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		error = StringUtil::Format("Extension \"%s\" not found.\n%s", filename, message);
 		return false;
 	}
+*/
 
-	auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
+/*	auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
 
 	// Parse the extension metadata from the extension binary
 	auto parsed_metadata = ParseExtensionMetaData(*handle);
@@ -256,7 +260,7 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 			throw InvalidInputException(metadata_mismatch_error);
 		}
 	}
-
+*/
 	auto filebase = fs.ExtractBaseName(filename);
 
 #ifdef WASM_LOADABLE_EXTENSIONS
@@ -294,6 +298,7 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 	result.lib_hdl = lib_hdl;
 
 	if (!direct_load) {
+/*
 		auto info_file_name = filename + ".info";
 
 		result.install_info = ExtensionInstallInfo::TryReadInfoFile(fs, info_file_name, lowercase_extension_name);
@@ -308,11 +313,12 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 			                  "extension using `FORCE INSTALL '%s'`",
 			                  filename, extension);
 		}
+*/
 	} else {
 		result.install_info = make_uniq<ExtensionInstallInfo>();
 		result.install_info->mode = ExtensionInstallMode::NOT_INSTALLED;
 		result.install_info->full_path = filename;
-		result.install_info->version = parsed_metadata.extension_version;
+		result.install_info->version = "ASD";//parsed_metadata.extension_version;
 	}
 
 	return true;

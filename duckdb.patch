diff --git a/src/include/duckdb/common/enable_shared_from_this.ipp b/src/include/duckdb/common/enable_shared_from_this_ipp.hpp
similarity index 100%
rename from src/include/duckdb/common/enable_shared_from_this.ipp
rename to src/include/duckdb/common/enable_shared_from_this_ipp.hpp
diff --git a/src/include/duckdb/common/shared_ptr.hpp b/src/include/duckdb/common/shared_ptr.hpp
index 6d0910ca6b..eff60e3db2 100644
--- a/src/include/duckdb/common/shared_ptr.hpp
+++ b/src/include/duckdb/common/shared_ptr.hpp
@@ -37,9 +37,9 @@ struct compatible_with_t : std::is_convertible<U *, T *> {}; // NOLINT: invalid
 
 } // namespace duckdb
 
-#include "duckdb/common/shared_ptr.ipp"
-#include "duckdb/common/weak_ptr.ipp"
-#include "duckdb/common/enable_shared_from_this.ipp"
+#include "duckdb/common/shared_ptr_ipp.hpp"
+#include "duckdb/common/weak_ptr_ipp.hpp"
+#include "duckdb/common/enable_shared_from_this_ipp.hpp"
 
 namespace duckdb {
 
diff --git a/src/include/duckdb/common/shared_ptr.ipp b/src/include/duckdb/common/shared_ptr_ipp.hpp
similarity index 100%
rename from src/include/duckdb/common/shared_ptr.ipp
rename to src/include/duckdb/common/shared_ptr_ipp.hpp
diff --git a/src/include/duckdb/common/weak_ptr.ipp b/src/include/duckdb/common/weak_ptr_ipp.hpp
similarity index 100%
rename from src/include/duckdb/common/weak_ptr.ipp
rename to src/include/duckdb/common/weak_ptr_ipp.hpp
diff --git a/extension/json/CMakeLists.txt b/extension/json/CMakeLists.txt
index 4101111df8..3e035e80d3 100644
--- a/extension/json/CMakeLists.txt
+++ b/extension/json/CMakeLists.txt
@@ -34,6 +34,7 @@ set(JSON_EXTENSION_FILES
 build_static_extension(json ${JSON_EXTENSION_FILES})
 set(PARAMETERS "-warnings")
 build_loadable_extension(json ${PARAMETERS} ${JSON_EXTENSION_FILES})
+target_link_libraries(json_loadable_extension duckdb_yyjson)
 
 install(
   TARGETS json_extension
diff --git a/src/include/duckdb/common/enable_shared_from_this.ipp b/src/include/duckdb/common/enable_shared_from_this.ipp
deleted file mode 100644
index 85cdd22054..0000000000
--- a/src/include/duckdb/common/enable_shared_from_this.ipp
+++ /dev/null
@@ -1,42 +0,0 @@
-namespace duckdb {
-
-template <class T>
-class enable_shared_from_this { // NOLINT: invalid case style
-public:
-	template <class U, bool SAFE>
-	friend class shared_ptr;
-
-private:
-	mutable weak_ptr<T> __weak_this_; // NOLINT: __weak_this_ is reserved
-
-protected:
-	constexpr enable_shared_from_this() noexcept {
-	}
-	enable_shared_from_this(enable_shared_from_this const &) noexcept { // NOLINT: not marked as explicit
-	}
-	enable_shared_from_this &operator=(enable_shared_from_this const &) noexcept {
-		return *this;
-	}
-	~enable_shared_from_this() {
-	}
-
-public:
-	shared_ptr<T> shared_from_this() { // NOLINT: invalid case style
-		return shared_ptr<T>(__weak_this_);
-	}
-	shared_ptr<T const> shared_from_this() const { // NOLINT: invalid case style
-		return shared_ptr<const T>(__weak_this_);
-	}
-
-#if _LIBCPP_STD_VER >= 17
-	weak_ptr<T> weak_from_this() noexcept { // NOLINT: invalid case style
-		return __weak_this_;
-	}
-
-	weak_ptr<const T> weak_from_this() const noexcept { // NOLINT: invalid case style
-		return __weak_this_;
-	}
-#endif // _LIBCPP_STD_VER >= 17
-};
-
-} // namespace duckdb
diff --git a/src/include/duckdb/common/file_open_flags.hpp b/src/include/duckdb/common/file_open_flags.hpp
index d0509a214b..1b5107e849 100644
--- a/src/include/duckdb/common/file_open_flags.hpp
+++ b/src/include/duckdb/common/file_open_flags.hpp
@@ -100,8 +100,9 @@ public:
 		return flags & FILE_FLAGS_PARALLEL_ACCESS;
 	}
 
-private:
 	idx_t flags = 0;
+
+private:
 	FileLockType lock = FileLockType::NO_LOCK;
 	FileCompressionType compression = FileCompressionType::UNCOMPRESSED;
 };
diff --git a/src/include/duckdb/common/shared_ptr.hpp b/src/include/duckdb/common/shared_ptr.hpp
index 6d0910ca6b..eff60e3db2 100644
--- a/src/include/duckdb/common/shared_ptr.hpp
+++ b/src/include/duckdb/common/shared_ptr.hpp
@@ -37,9 +37,9 @@ struct compatible_with_t : std::is_convertible<U *, T *> {}; // NOLINT: invalid
 
 } // namespace duckdb
 
-#include "duckdb/common/shared_ptr.ipp"
-#include "duckdb/common/weak_ptr.ipp"
-#include "duckdb/common/enable_shared_from_this.ipp"
+#include "duckdb/common/shared_ptr_ipp.hpp"
+#include "duckdb/common/weak_ptr_ipp.hpp"
+#include "duckdb/common/enable_shared_from_this_ipp.hpp"
 
 namespace duckdb {
 
diff --git a/src/include/duckdb/common/shared_ptr.ipp b/src/include/duckdb/common/shared_ptr.ipp
deleted file mode 100644
index d046dc1412..0000000000
--- a/src/include/duckdb/common/shared_ptr.ipp
+++ /dev/null
@@ -1,268 +0,0 @@
-namespace duckdb {
-
-template <typename T, bool SAFE = true>
-class weak_ptr;
-
-template <class T>
-class enable_shared_from_this;
-
-template <typename T, bool SAFE = true>
-class shared_ptr { // NOLINT: invalid case style
-public:
-	using original = std::shared_ptr<T>;
-	using element_type = typename original::element_type;
-	using weak_type = weak_ptr<T, SAFE>;
-
-private:
-	static inline void AssertNotNull(const bool null) {
-#if defined(DUCKDB_DEBUG_NO_SAFETY) || defined(DUCKDB_CLANG_TIDY)
-		return;
-#else
-		if (DUCKDB_UNLIKELY(null)) {
-			throw duckdb::InternalException("Attempted to dereference shared_ptr that is NULL!");
-		}
-#endif
-	}
-
-private:
-	template <class U, bool SAFE_P>
-	friend class weak_ptr;
-
-	template <class U, bool SAFE_P>
-	friend class shared_ptr;
-
-	template <typename U, typename S>
-	friend shared_ptr<S> shared_ptr_cast(shared_ptr<U> src); // NOLINT: invalid case style
-
-private:
-	original internal;
-
-public:
-	// Constructors
-	shared_ptr() : internal() {
-	}
-	shared_ptr(std::nullptr_t) : internal(nullptr) { // NOLINT: not marked as explicit
-	}
-
-	// From raw pointer of type U convertible to T
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	explicit shared_ptr(U *ptr) : internal(ptr) {
-		__enable_weak_this(internal.get(), internal.get());
-	}
-	// From raw pointer of type T with custom DELETER
-	template <typename DELETER>
-	shared_ptr(T *ptr, DELETER deleter) : internal(ptr, deleter) {
-		__enable_weak_this(internal.get(), internal.get());
-	}
-	// Aliasing constructor: shares ownership information with ref but contains ptr instead
-	// When the created shared_ptr goes out of scope, it will call the DELETER of ref, will not delete ptr
-	template <class U>
-	shared_ptr(const shared_ptr<U> &ref, T *ptr) noexcept : internal(ref.internal, ptr) {
-	}
-#if _LIBCPP_STD_VER >= 20
-	template <class U>
-	shared_ptr(shared_ptr<U> &&ref, T *ptr) noexcept : internal(std::move(ref.internal), ptr) {
-	}
-#endif
-
-	// Copy constructor, share ownership with ref
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	shared_ptr(const shared_ptr<U> &ref) noexcept : internal(ref.internal) { // NOLINT: not marked as explicit
-	}
-	shared_ptr(const shared_ptr &other) : internal(other.internal) { // NOLINT: not marked as explicit
-	}
-	// Move constructor, share ownership with ref
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	shared_ptr(shared_ptr<U> &&ref) noexcept // NOLINT: not marked as explicit
-	    : internal(std::move(ref.internal)) {
-	}
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	shared_ptr(shared_ptr<T> &&other) // NOLINT: not marked as explicit
-	    : internal(std::move(other.internal)) {
-	}
-
-	// Construct from std::shared_ptr
-	explicit shared_ptr(std::shared_ptr<T> other) : internal(other) {
-		// FIXME: should we __enable_weak_this here?
-		// *our* enable_shared_from_this hasn't initialized yet, so I think so?
-		__enable_weak_this(internal.get(), internal.get());
-	}
-
-	// Construct from weak_ptr
-	template <class U>
-	explicit shared_ptr(weak_ptr<U> other) : internal(other.internal) {
-	}
-
-	// Construct from unique_ptr, takes over ownership of the unique_ptr
-	template <class U, class DELETER, bool SAFE_P,
-	          typename std::enable_if<compatible_with_t<U, T>::value &&
-	                                      std::is_convertible<typename unique_ptr<U, DELETER>::pointer, T *>::value,
-	                                  int>::type = 0>
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	shared_ptr(unique_ptr<U, DELETER, SAFE_P> &&other) // NOLINT: not marked as explicit
-	    : internal(std::move(other)) {
-		__enable_weak_this(internal.get(), internal.get());
-	}
-
-	// Destructor
-	~shared_ptr() = default;
-
-	// Assign from shared_ptr copy
-	shared_ptr<T> &operator=(const shared_ptr &other) noexcept {
-		if (this == &other) {
-			return *this;
-		}
-		// Create a new shared_ptr using the copy constructor, then swap out the ownership to *this
-		shared_ptr(other).swap(*this);
-		return *this;
-	}
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	shared_ptr<T> &operator=(const shared_ptr<U> &other) {
-		shared_ptr(other).swap(*this);
-		return *this;
-	}
-
-	// Assign from moved shared_ptr
-	shared_ptr<T> &operator=(shared_ptr &&other) noexcept {
-		// Create a new shared_ptr using the move constructor, then swap out the ownership to *this
-		shared_ptr(std::move(other)).swap(*this);
-		return *this;
-	}
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	shared_ptr<T> &operator=(shared_ptr<U> &&other) {
-		shared_ptr(std::move(other)).swap(*this);
-		return *this;
-	}
-
-	// Assign from moved unique_ptr
-	template <class U, class DELETER, bool SAFE_P,
-	          typename std::enable_if<compatible_with_t<U, T>::value &&
-	                                      std::is_convertible<typename unique_ptr<U, DELETER>::pointer, T *>::value,
-	                                  int>::type = 0>
-	shared_ptr<T> &operator=(unique_ptr<U, DELETER, SAFE_P> &&ref) {
-		shared_ptr(std::move(ref)).swap(*this);
-		return *this;
-	}
-
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	void
-	reset() { // NOLINT: invalid case style
-		internal.reset();
-	}
-	template <typename U>
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	void
-	reset(U *ptr) { // NOLINT: invalid case style
-		internal.reset(ptr);
-	}
-	template <typename U, typename DELETER>
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	void
-	reset(U *ptr, DELETER deleter) { // NOLINT: invalid case style
-		internal.reset(ptr, deleter);
-	}
-
-	void swap(shared_ptr &r) noexcept { // NOLINT: invalid case style
-		internal.swap(r.internal);
-	}
-
-	T *get() const { // NOLINT: invalid case style
-		return internal.get();
-	}
-
-	long use_count() const { // NOLINT: invalid case style
-		return internal.use_count();
-	}
-
-	explicit operator bool() const noexcept {
-		return internal.operator bool();
-	}
-
-	typename std::add_lvalue_reference<T>::type operator*() const {
-		if (MemorySafety<SAFE>::ENABLED) {
-			const auto ptr = internal.get();
-			AssertNotNull(!ptr);
-			return *ptr;
-		} else {
-			return *internal;
-		}
-	}
-
-	T *operator->() const {
-		if (MemorySafety<SAFE>::ENABLED) {
-			const auto ptr = internal.get();
-			AssertNotNull(!ptr);
-			return ptr;
-		} else {
-			return internal.operator->();
-		}
-	}
-
-	// Relational operators
-	template <typename U>
-	bool operator==(const shared_ptr<U> &other) const noexcept {
-		return internal == other.internal;
-	}
-	template <typename U>
-	bool operator!=(const shared_ptr<U> &other) const noexcept {
-		return internal != other.internal;
-	}
-
-	bool operator==(std::nullptr_t) const noexcept {
-		return internal == nullptr;
-	}
-	bool operator!=(std::nullptr_t) const noexcept {
-		return internal != nullptr;
-	}
-
-	template <typename U>
-	bool operator<(const shared_ptr<U> &other) const noexcept {
-		return internal < other.internal;
-	}
-	template <typename U>
-	bool operator<=(const shared_ptr<U> &other) const noexcept {
-		return internal <= other.internal;
-	}
-	template <typename U>
-	bool operator>(const shared_ptr<U> &other) const noexcept {
-		return internal > other.internal;
-	}
-	template <typename U>
-	bool operator>=(const shared_ptr<U> &other) const noexcept {
-		return internal >= other.internal;
-	}
-
-private:
-	// This overload is used when the class inherits from 'enable_shared_from_this<U>'
-	template <class U, class V,
-	          typename std::enable_if<std::is_convertible<V *, const enable_shared_from_this<U> *>::value,
-	                                  int>::type = 0>
-	void __enable_weak_this(const enable_shared_from_this<U> *object, // NOLINT: invalid case style
-	                        V *ptr) noexcept {
-		typedef typename std::remove_cv<U>::type non_const_u_t;
-		if (object && object->__weak_this_.expired()) {
-			// __weak_this__ is the mutable variable returned by 'shared_from_this'
-			// it is initialized here
-			auto non_const = const_cast<non_const_u_t *>(static_cast<const U *>(ptr)); // NOLINT: const cast
-			object->__weak_this_ = shared_ptr<non_const_u_t>(*this, non_const);
-		}
-	}
-
-	void __enable_weak_this(...) noexcept { // NOLINT: invalid case style
-	}
-};
-
-} // namespace duckdb
diff --git a/src/include/duckdb/common/weak_ptr.ipp b/src/include/duckdb/common/weak_ptr.ipp
deleted file mode 100644
index 076fde9532..0000000000
--- a/src/include/duckdb/common/weak_ptr.ipp
+++ /dev/null
@@ -1,117 +0,0 @@
-namespace duckdb {
-
-template <typename T, bool SAFE>
-class weak_ptr { // NOLINT: invalid case style
-public:
-	using original = std::weak_ptr<T>;
-	using element_type = typename original::element_type;
-
-private:
-	template <class U, bool SAFE_P>
-	friend class shared_ptr;
-
-private:
-	original internal;
-
-public:
-	// Constructors
-	weak_ptr() : internal() {
-	}
-
-	// NOLINTBEGIN
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	weak_ptr(shared_ptr<U, SAFE> const &ptr) noexcept : internal(ptr.internal) {
-	}
-	weak_ptr(weak_ptr const &other) noexcept : internal(other.internal) {
-	}
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	weak_ptr(weak_ptr<U> const &ptr) noexcept : internal(ptr.internal) {
-	}
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	weak_ptr(weak_ptr &&ptr) noexcept
-	    : internal(std::move(ptr.internal)) {
-	}
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-#ifdef DUCKDB_CLANG_TIDY
-	[[clang::reinitializes]]
-#endif
-	weak_ptr(weak_ptr<U> &&ptr) noexcept
-	    : internal(std::move(ptr.internal)) {
-	}
-	// NOLINTEND
-	// Destructor
-	~weak_ptr() = default;
-
-	// Assignment operators
-	weak_ptr &operator=(const weak_ptr &other) {
-		if (this == &other) {
-			return *this;
-		}
-		internal = other.internal;
-		return *this;
-	}
-
-	template <class U, typename std::enable_if<compatible_with_t<U, T>::value, int>::type = 0>
-	weak_ptr &operator=(const shared_ptr<U, SAFE> &ptr) {
-		internal = ptr.internal;
-		return *this;
-	}
-
-	// Modifiers
-#ifdef DUCKDB_CLANG_TIDY
-	// This is necessary to tell clang-tidy that it reinitializes the variable after a move
-	[[clang::reinitializes]]
-#endif
-	void
-	reset() { // NOLINT: invalid case style
-		internal.reset();
-	}
-
-	// Observers
-	long use_count() const { // NOLINT: invalid case style
-		return internal.use_count();
-	}
-
-	bool expired() const { // NOLINT: invalid case style
-		return internal.expired();
-	}
-
-	shared_ptr<T, SAFE> lock() const { // NOLINT: invalid case style
-		return shared_ptr<T, SAFE>(internal.lock());
-	}
-
-	// Relational operators
-	template <typename U>
-	bool operator==(const weak_ptr<U> &other) const noexcept {
-		return internal == other.internal;
-	}
-
-	template <typename U>
-	bool operator!=(const weak_ptr<U> &other) const noexcept {
-		return internal != other.internal;
-	}
-
-	template <typename U>
-	bool operator<(const weak_ptr<U> &other) const noexcept {
-		return internal < other.internal;
-	}
-
-	template <typename U>
-	bool operator<=(const weak_ptr<U> &other) const noexcept {
-		return internal <= other.internal;
-	}
-
-	template <typename U>
-	bool operator>(const weak_ptr<U> &other) const noexcept {
-		return internal > other.internal;
-	}
-
-	template <typename U>
-	bool operator>=(const weak_ptr<U> &other) const noexcept {
-		return internal >= other.internal;
-	}
-};
-
-} // namespace duckdb
diff --git a/src/include/duckdb/main/extension_install_info.hpp b/src/include/duckdb/main/extension_install_info.hpp
index 64b7b520a7..b03f64b3aa 100644
--- a/src/include/duckdb/main/extension_install_info.hpp
+++ b/src/include/duckdb/main/extension_install_info.hpp
@@ -49,9 +49,9 @@ public:
 
 struct ExtensionRepository {
 	//! All currently available repositories
-	static constexpr const char *CORE_REPOSITORY_URL = "http://extensions.duckdb.org";
-	static constexpr const char *CORE_NIGHTLY_REPOSITORY_URL = "http://nightly-extensions.duckdb.org";
-	static constexpr const char *COMMUNITY_REPOSITORY_URL = "http://community-extensions.duckdb.org";
+	static constexpr const char *CORE_REPOSITORY_URL = "https://extensions.duckdb.org";
+	static constexpr const char *CORE_NIGHTLY_REPOSITORY_URL = "https://nightly-extensions.duckdb.org";
+	static constexpr const char *COMMUNITY_REPOSITORY_URL = "https://community-extensions.duckdb.org";
 
 	//! Debugging repositories (target local, relative paths that are produced by DuckDB's build system)
 	static constexpr const char *BUILD_DEBUG_REPOSITORY_PATH = "./build/debug/repository";
diff --git a/src/main/extension/extension_helper.cpp b/src/main/extension/extension_helper.cpp
index 3954e232b7..9679e18d05 100644
--- a/src/main/extension/extension_helper.cpp
+++ b/src/main/extension/extension_helper.cpp
@@ -304,7 +304,6 @@ vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(DatabaseInstance
 
 	auto &config = DBConfig::GetConfig(db);
 
-#ifndef WASM_LOADABLE_EXTENSIONS
 	case_insensitive_set_t seen_extensions;
 
 	// scan the install directory for installed extensions
@@ -321,7 +320,6 @@ vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(DatabaseInstance
 
 		result.push_back(UpdateExtensionInternal(db, fs, fs.JoinPath(ext_directory, path), extension_name));
 	});
-#endif
 
 	for (const auto &extension : db.LoadedExtensions()) {
 		if (seen_extensions.find(extension) != seen_extensions.end()) {
diff --git a/src/main/extension/extension_install.cpp b/src/main/extension/extension_install.cpp
index d188cb5dc3..d323fe9d7a 100644
--- a/src/main/extension/extension_install.cpp
+++ b/src/main/extension/extension_install.cpp
@@ -194,7 +194,7 @@ string ExtensionHelper::ExtensionUrlTemplate(optional_ptr<const DBConfig> db_con
 		versioned_path = "/${REVISION}/${PLATFORM}/${NAME}.duckdb_extension";
 	}
 #ifdef WASM_LOADABLE_EXTENSIONS
-	string default_endpoint = DEFAULT_REPOSITORY;
+	string default_endpoint = ExtensionRepository::DEFAULT_REPOSITORY_URL;
 	versioned_path = versioned_path + ".wasm";
 #else
 	string default_endpoint = ExtensionRepository::DEFAULT_REPOSITORY_URL;
diff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp
index 65438aa8ec..1185bccbc7 100644
--- a/src/main/extension/extension_load.cpp
+++ b/src/main/extension/extension_load.cpp
@@ -175,7 +175,8 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		direct_load = false;
 		string extension_name = ApplyExtensionAlias(extension);
 #ifdef WASM_LOADABLE_EXTENSIONS
-		string url_template = ExtensionUrlTemplate(&config, "");
+		ExtensionRepository repository;
+		string url_template = ExtensionUrlTemplate(&config, repository, "");
 		string url = ExtensionFinalizeUrlTemplate(url_template, extension_name);
 
 		char *str = (char *)EM_ASM_PTR(
@@ -215,68 +216,223 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		direct_load = true;
 		filename = fs.ExpandPath(filename);
 	}
-	if (!fs.FileExists(filename)) {
-		string message;
-		bool exact_match = ExtensionHelper::CreateSuggestions(extension, message);
-		if (exact_match) {
-			message += "\nInstall it first using \"INSTALL " + extension + "\".";
-		}
-		error = StringUtil::Format("Extension \"%s\" not found.\n%s", filename, message);
-		return false;
-	}
-
-	auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
+	/*	if (!fs.FileExists(filename)) {
+	        string message;
+	        bool exact_match = ExtensionHelper::CreateSuggestions(extension, message);
+	        if (exact_match) {
+	            message += "\nInstall it first using \"INSTALL " + extension + "\".";
+	        }
+	        error = StringUtil::Format("Extension \"%s\" not found.\n%s", filename, message);
+	        return false;
+	    }
+	*/
+
+	/*	auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
+
+	    // Parse the extension metadata from the extension binary
+	    auto parsed_metadata = ParseExtensionMetaData(*handle);
+
+	    auto metadata_mismatch_error = parsed_metadata.GetInvalidMetadataError();
+
+	    if (!metadata_mismatch_error.empty()) {
+	        metadata_mismatch_error = StringUtil::Format("Failed to load '%s', %s", extension, metadata_mismatch_error);
+	    }
+
+	    if (!config.options.allow_unsigned_extensions) {
+	        bool signature_valid =
+	            CheckExtensionSignature(*handle, parsed_metadata, config.options.allow_community_extensions);
+
+	        if (!signature_valid) {
+	            throw IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename) +
+	                              metadata_mismatch_error);
+	        }
+
+	        if (!metadata_mismatch_error.empty()) {
+	            // Signed extensions perform the full check
+	            throw InvalidInputException(metadata_mismatch_error);
+	        }
+	    } else if (!config.options.allow_extensions_metadata_mismatch) {
+	        if (!metadata_mismatch_error.empty()) {
+	            // Unsigned extensions AND configuration allowing n, loading allowed, mainly for
+	            // debugging purposes
+	            throw InvalidInputException(metadata_mismatch_error);
+	        }
+	    }
+	*/
+	auto filebase = fs.ExtractBaseName(filename);
 
-	// Parse the extension metadata from the extension binary
-	auto parsed_metadata = ParseExtensionMetaData(*handle);
+#ifdef WASM_LOADABLE_EXTENSIONS
+	auto basename = fs.ExtractBaseName(filename);
+	char *exe = NULL;
+	exe = (char *)EM_ASM_PTR(
+	    {
+		    // Next few lines should argubly in separate JavaScript-land function call
+		    // TODO: move them out / have them configurable
 
-	auto metadata_mismatch_error = parsed_metadata.GetInvalidMetadataError();
+		    var url = (UTF8ToString($0));
+
+		    if (typeof XMLHttpRequest === "undefined") {
+			    const os = require('os');
+			    const path = require('path');
+			    const fs = require('fs');
+
+			    var array = url.split("/");
+			    var l = array.length;
+
+			    var folder = path.join(os.homedir(), ".duckdb/extensions/" + array[l - 4] + "/" + array[l - 3] + "/" +
+			                                             array[l - 2] + "/");
+			    var filePath = path.join(folder, array[l - 1]);
+
+			    try {
+				    if (!fs.existsSync(folder)) {
+					    fs.mkdirSync(folder, {recursive : true});
+				    }
+
+				    if (!fs.existsSync(filePath)) {
+					    const int32 = new Int32Array(new SharedArrayBuffer(8));
+					    var Worker = require('node:worker_threads').Worker;
+                var worker = new Worker("const {Worker,isMainThread,parentPort,workerData,} = require('node:worker_threads');var times = 0;var SAB = 23;var Z = 0; async function ZZZ(e) {var x = await fetch(e);var res = await x.arrayBuffer();Atomics.store(SAB, 1, res.byteLength);Atomics.store(SAB, 0, 1);Atomics.notify(SAB, 1);Atomics.notify(SAB, 0);Z = res;};parentPort.on('message', function(event) {if (times == 0) {times++;SAB = event;} else if (times == 1) {times++; ZZZ(event);} else {const a = new Uint8Array(Z);const b = new Uint8Array(event.buffer);var K = Z.byteLength;for (var i = 0; i < K; i++) {b[i] = a[i];}Atomics.notify(event, 0);Atomics.store(SAB, 0, 2);Atomics.notify(SAB, 0);}});", {
+                    eval: true
+                });
+					    var uInt8Array;
+
+					    int32[0] = 0;
+					    int32[2] = 4;
+					    worker.postMessage(int32);
+
+					    worker.postMessage(url);
+					    Atomics.wait(int32, 0, 0);
+
+					    const int32_2 = new Int32Array(new SharedArrayBuffer(int32[1] + 3 - ((int32[1] + 3) % 4)));
+					    worker.postMessage(int32_2);
+
+					    Atomics.wait(int32, 0, 1);
+
+					    var x = new Uint8Array(int32_2.buffer, 0, int32[1]);
+					    uInt8Array = x;
+					    worker.terminate();
+					    fs.writeFileSync(filePath, uInt8Array);
+
+				    } else {
+					    uInt8Array = fs.readFileSync(filePath);
+				    }
+			    } catch (e) {
+				    console.log("Error fetching module", e);
+				    return 0;
+			    }
+		    } else {
+			    const xhr = new XMLHttpRequest();
+			    xhr.open("GET", url, false);
+			    xhr.responseType = "arraybuffer";
+			    xhr.send(null);
+			    if (xhr.status != 200)
+				    return 0;
+			    uInt8Array = xhr.response;
+		    }
+
+		    var valid = WebAssembly.validate(uInt8Array);
+		    var len = uInt8Array.byteLength;
+		    var fileOnWasmHeap = _malloc(len + 4);
+
+		    var properArray = new Uint8Array(uInt8Array);
+
+		    for (var iii = 0; iii < len; iii++) {
+			    Module.HEAPU8[iii + fileOnWasmHeap + 4] = properArray[iii];
+		    }
+		    var LEN123 = new Uint8Array(4);
+		    LEN123[0] = len % 256;
+		    len -= LEN123[0];
+		    len /= 256;
+		    LEN123[1] = len % 256;
+		    len -= LEN123[1];
+		    len /= 256;
+		    LEN123[2] = len % 256;
+		    len -= LEN123[2];
+		    len /= 256;
+		    LEN123[3] = len % 256;
+		    len -= LEN123[3];
+		    len /= 256;
+		    Module.HEAPU8.set(LEN123, fileOnWasmHeap);
+		    // FIXME: found how to expose those to the logger interface
+		    // console.log(LEN123);
+		    // console.log(properArray);
+		    // console.log(new Uint8Array(Module.HEAPU8, fileOnWasmHeap, len+4));
+		    // console.log('Loading extension ', UTF8ToString($1));
 
-	if (!metadata_mismatch_error.empty()) {
-		metadata_mismatch_error = StringUtil::Format("Failed to load '%s', %s", extension, metadata_mismatch_error);
+		    // Here we add the uInt8Array to Emscripten's filesystem, for it to be found by dlopen
+		    FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
+		    return fileOnWasmHeap;
+	    },
+	    filename.c_str(), basename.c_str());
+	if (!exe) {
+		throw IOException("Extension %s is not available", filename);
 	}
 
+	auto dopen_from = basename;
 	if (!config.options.allow_unsigned_extensions) {
-		bool signature_valid =
-		    CheckExtensionSignature(*handle, parsed_metadata, config.options.allow_community_extensions);
+		// signature is the last 256 bytes of the file
+
+		string signature;
+		signature.resize(256);
+
+		D_ASSERT(exe);
+		uint64_t LEN = 0;
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[3];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[2];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[1];
+		LEN *= 256;
+		LEN += ((uint8_t *)exe)[0];
+		auto signature_offset = LEN - signature.size();
+
+		const idx_t maxLenChunks = 1024ULL * 1024ULL;
+		const idx_t numChunks = (signature_offset + maxLenChunks - 1) / maxLenChunks;
+		std::vector<std::string> hash_chunks(numChunks);
+		std::vector<idx_t> splits(numChunks + 1);
+
+		for (idx_t i = 0; i < numChunks; i++) {
+			splits[i] = maxLenChunks * i;
+		}
+		splits.back() = signature_offset;
+
+		for (idx_t i = 0; i < numChunks; i++) {
+			string x;
+			x.resize(splits[i + 1] - splits[i]);
+			for (idx_t j = 0; j < x.size(); j++) {
+				x[j] = ((uint8_t *)exe)[j + 4 + splits[i]];
+			}
+			ComputeSHA256String(x, &hash_chunks[i]);
+		}
 
-		if (!signature_valid) {
-			throw IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename) +
-			                  metadata_mismatch_error);
+		string hash_concatenation;
+		hash_concatenation.reserve(32 * numChunks); // 256 bits -> 32 bytes per chunk
+
+		for (auto &hash_chunk : hash_chunks) {
+			hash_concatenation += hash_chunk;
 		}
 
-		if (!metadata_mismatch_error.empty()) {
-			// Signed extensions perform the full check
-			throw InvalidInputException(metadata_mismatch_error);
+		string two_level_hash;
+		ComputeSHA256String(hash_concatenation, &two_level_hash);
+
+		for (idx_t j = 0; j < signature.size(); j++) {
+			signature[j] = ((uint8_t *)exe)[4 + signature_offset + j];
 		}
-	} else if (!config.options.allow_extensions_metadata_mismatch) {
-		if (!metadata_mismatch_error.empty()) {
-			// Unsigned extensions AND configuration allowing n, loading allowed, mainly for
-			// debugging purposes
-			throw InvalidInputException(metadata_mismatch_error);
+		bool any_valid = false;
+		for (auto &key : ExtensionHelper::GetPublicKeys()) {
+			if (duckdb_mbedtls::MbedTlsWrapper::IsValidSha256Signature(key, signature, two_level_hash)) {
+				any_valid = true;
+				break;
+			}
+		}
+		if (!any_valid) {
+			throw IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename));
 		}
 	}
-
-	auto filebase = fs.ExtractBaseName(filename);
-
-#ifdef WASM_LOADABLE_EXTENSIONS
-	EM_ASM(
-	    {
-		    // Next few lines should argubly in separate JavaScript-land function call
-		    // TODO: move them out / have them configurable
-		    const xhr = new XMLHttpRequest();
-		    xhr.open("GET", UTF8ToString($0), false);
-		    xhr.responseType = "arraybuffer";
-		    xhr.send(null);
-		    var uInt8Array = xhr.response;
-		    WebAssembly.validate(uInt8Array);
-		    console.log('Loading extension ', UTF8ToString($1));
-
-		    // Here we add the uInt8Array to Emscripten's filesystem, for it to be found by dlopen
-		    FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
-	    },
-	    filename.c_str(), filebase.c_str());
-	auto dopen_from = filebase;
+	if (exe) {
+		free(exe);
+	}
 #else
 	auto dopen_from = filename;
 #endif
@@ -294,25 +450,27 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 	result.lib_hdl = lib_hdl;
 
 	if (!direct_load) {
-		auto info_file_name = filename + ".info";
-
-		result.install_info = ExtensionInstallInfo::TryReadInfoFile(fs, info_file_name, lowercase_extension_name);
-
-		if (result.install_info->mode == ExtensionInstallMode::UNKNOWN) {
-			// The info file was missing, we just set the version, since we have it from the parsed footer
-			result.install_info->version = parsed_metadata.extension_version;
-		}
-
-		if (result.install_info->version != parsed_metadata.extension_version) {
-			throw IOException("Metadata mismatch detected when loading extension '%s'\nPlease try reinstalling the "
-			                  "extension using `FORCE INSTALL '%s'`",
-			                  filename, extension);
-		}
+		/*
+		        auto info_file_name = filename + ".info";
+
+		        result.install_info = ExtensionInstallInfo::TryReadInfoFile(fs, info_file_name,
+		   lowercase_extension_name);
+
+		        if (result.install_info->mode == ExtensionInstallMode::UNKNOWN) {
+		            // The info file was missing, we just set the version, since we have it from the parsed footer
+		            result.install_info->version = parsed_metadata.extension_version;
+		        }
+
+		        if (result.install_info->version != parsed_metadata.extension_version) {
+		            throw IOException("Metadata mismatch detected when loading extension '%s'\nPlease try reinstalling
+		   the " "extension using `FORCE INSTALL '%s'`", filename, extension);
+		        }
+		*/
 	} else {
 		result.install_info = make_uniq<ExtensionInstallInfo>();
 		result.install_info->mode = ExtensionInstallMode::NOT_INSTALLED;
 		result.install_info->full_path = filename;
-		result.install_info->version = parsed_metadata.extension_version;
+		result.install_info->version = ""; // parsed_metadata.extension_version;
 	}
 
 	return true;

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 24f6430f44..a1b9dd0519 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -121,6 +121,12 @@ endif()
 option(FORCE_WARN_UNUSED "Unused code objects lead to compiler warnings." FALSE)
 
 option(WASM_LOADABLE_EXTENSIONS "WebAssembly build with loadable extensions." FALSE)
+
+if($ENV{WASM_LOADABLE_EXTENSIONS})
+  set(WASM_LOADABLE_EXTENSIONS TRUE)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DDUCKDB_ENABLE_DEPRECATED_API")
+endif()
+
 option(ENABLE_SANITIZER "Enable address sanitizer." TRUE)
 option(ENABLE_THREAD_SANITIZER "Enable thread sanitizer." FALSE)
 option(ENABLE_UBSAN "Enable undefined behavior sanitizer." TRUE)
diff --git a/extension/parquet/CMakeLists.txt b/extension/parquet/CMakeLists.txt
index cc9e8dfeaf..43a93ab365 100644
--- a/extension/parquet/CMakeLists.txt
+++ b/extension/parquet/CMakeLists.txt
@@ -1,3 +1,4 @@
+return()
 cmake_minimum_required(VERSION 2.8.12)
 
 project(ParquetExtension)
diff --git a/src/include/duckdb/function/cast/default_casts.hpp b/src/include/duckdb/function/cast/default_casts.hpp
index 448c9c86f3..af7b5e037e 100644
--- a/src/include/duckdb/function/cast/default_casts.hpp
+++ b/src/include/duckdb/function/cast/default_casts.hpp
@@ -82,12 +82,20 @@ struct CastLocalStateParameters {
 
 typedef bool (*cast_function_t)(Vector &source, Vector &result, idx_t count, CastParameters &parameters);
 typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t)(CastLocalStateParameters &parameters);
+typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t2)(ClientContext &parameters);
+
+//static_assert(
 
 struct BoundCastInfo {
 	DUCKDB_API
 	BoundCastInfo(
 	    cast_function_t function, unique_ptr<BoundCastData> cast_data = nullptr,
 	    init_cast_local_state_t init_local_state = nullptr); // NOLINT: allow explicit cast from cast_function_t
+
+	BoundCastInfo(
+	    cast_function_t function, unique_ptr<BoundCastData> cast_data,
+	    init_cast_local_state_t2 init_cast_local_state) : BoundCastInfo(std::move(function), std::move(cast_data), (init_cast_local_state_t)std::move(init_cast_local_state)){} // NOLINT: allow explicit cast from cast_function_t
+
 	cast_function_t function;
 	init_cast_local_state_t init_local_state;
 	unique_ptr<BoundCastData> cast_data;
diff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp
index 95ac02aacb..c6c6ffaa75 100644
--- a/src/main/extension/extension_load.cpp
+++ b/src/main/extension/extension_load.cpp
@@ -37,6 +37,38 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileOpener *opener, const
 
 	// shorthand case
 	if (!ExtensionHelper::IsFullPath(extension)) {
+#ifdef WASM_LOADABLE_EXTENSIONS
+		// This to be refactored away
+		char *str = (char *)EM_ASM_PTR({
+			var jsString = ((typeof runtime === 'object') && runtime && (typeof runtime.whereToLoad === 'function') && runtime.whereToLoad) ? runtime.whereToLoad(UTF8ToString($0)) : ("https://s3/extension-eh/wip/" + UTF8ToString($0) + ".duckdb_extension.wasm");
+			var lengthBytes = lengthBytesUTF8(jsString) + 1;
+			// 'jsString.length' would return the length of the string as UTF-16
+			// units, but Emscripten C strings operate as UTF-8.
+			var stringOnWasmHeap = _malloc(lengthBytes);
+			stringToUTF8(jsString, stringOnWasmHeap, lengthBytes);
+			return stringOnWasmHeap;
+		}, filename.c_str());
+		std::string address(str);
+		free(str);
+
+		filename = address;
+		if (!fs.FileExists(filename)) {
+			// This to be refactored away
+			char *str = (char *)EM_ASM_PTR({
+				var jsString = "./extension-eh/" + UTF8ToString($0) + ".duckdb_extension.wasm";
+				var lengthBytes = lengthBytesUTF8(jsString) + 1;
+				// 'jsString.length' would return the length of the string as UTF-16
+				// units, but Emscripten C strings operate as UTF-8.
+				var stringOnWasmHeap = _malloc(lengthBytes);
+				stringToUTF8(jsString, stringOnWasmHeap, lengthBytes);
+				return stringOnWasmHeap;
+			}, filename.c_str());
+			std::string address(str);
+			free(str);
+
+			filename = address;
+		}
+#else
 		string local_path = !config.options.extension_directory.empty() ? config.options.extension_directory
 		                                                                : fs.GetHomeDirectory(opener);
 
@@ -50,6 +82,7 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileOpener *opener, const
 		}
 		string extension_name = ApplyExtensionAlias(extension);
 		filename = fs.JoinPath(local_path, extension_name + ".duckdb_extension");
+#endif
 	}
 	if (!fs.FileExists(filename)) {
 		string message;
@@ -87,7 +120,19 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileOpener *opener, const
 			}
 		}
 		if (!any_valid) {
+#ifdef WASM_LOADABLE_EXTENSIONS
+	EM_ASM(
+	    {
+			//if ((typeof runtime === 'object') && runtime && (typeof runtime.unsignedExtensionWarning === 'function') && runtime.unsignedExtensionWarning)
+			//	runtime.unsignedExtensionWarning(UTF8ToString($0));
+			//else
+				console.log("Loading DuckDB-Wasm unsigned extension from " + UTF8ToString($0));
+
+	    },
+	    filename.c_str());
+#else
 			throw IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename));
+#endif
 		}
 	}
 	auto basename = fs.ExtractBaseName(filename);

diff --git a/.github/patches/extensions/spatial/no_network.patch b/.github/patches/extensions/spatial/no_network.patch
new file mode 100644
index 0000000000..06dac7cc5a
--- /dev/null
+++ b/.github/patches/extensions/spatial/no_network.patch
@@ -0,0 +1,102 @@
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index eb7183d..4324558 100644
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -11,7 +11,7 @@ project(${TARGET_NAME})
+ # Options
+ 
+ # Enable network functionality (OpenSSL and GDAL's CURL based fs/drivers)
+-option(SPATIAL_USE_NETWORK "Enable network functionality" ON)
++option(SPATIAL_USE_NETWORK "Enable network functionality" OFF)
+ 
+ include_directories(spatial/include)
+ add_subdirectory(spatial/src)
+@@ -32,6 +32,9 @@ execute_process(
+   # Generate project
+   COMMAND
+     ${CMAKE_COMMAND} -G ${CMAKE_GENERATOR}
++    -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE}
++    -DDUCKDB_ENABLE_DEPRECATED_API=1
++    -DWASM_LOADABLE_EXTENSIONS=1
+     -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
+     -DOSX_BUILD_ARCH=${OSX_BUILD_ARCH}
+     -DSPATIAL_USE_NETWORK=${SPATIAL_USE_NETWORK} 
+@@ -58,10 +61,11 @@ set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH}
+                       ${CMAKE_BINARY_DIR}/deps/local)
+ set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES} MD.lib
+ )# annoyingly for expat on windows
+-set(ZLIB_USE_STATIC_LIBS ON)
+-set(OPENSSL_USE_STATIC_LIBS ON)
++
++set(ZLIB_USE_STATIC_LIBS OFF)
++set(OPENSSL_USE_STATIC_LIBS OFF)
+ find_library(SQLITE3_MEMVFS memvfs)
+-find_package(ZLIB REQUIRED)
++#find_library(ZLIB REQUIRED)
+ find_package(PROJ REQUIRED)
+ find_package(SQLite3 REQUIRED)
+ find_package(GEOS REQUIRED)
+@@ -93,13 +97,6 @@ if(WIN32)
+   list(APPEND EXTENSION_DEPENDENCIES wbemuuid.lib)
+ endif()
+ 
+-if(APPLE)
+-  find_library(CoreFoundation_Library CoreFoundation)
+-  find_library(SystemConfiguration_Library SystemConfiguration)
+-  list(APPEND EXTENSION_DEPENDENCIES ${CoreFoundation_Library}
+-                                     ${SystemConfiguration_Library})
+-endif()
+-
+ # Geographiclib is special
+ include_directories(${GeographicLib_INCLUDE_DIRS})
+ 
+diff --git a/deps/CMakeLists.txt b/deps/CMakeLists.txt
+index 115df4e..5d338a3 100644
+--- a/deps/CMakeLists.txt
++++ b/deps/CMakeLists.txt
+@@ -41,6 +41,7 @@ ExternalProject_Add(
+     -DCMAKE_TOOLCHAIN_FILE='${CMAKE_TOOLCHAIN_FILE}'
+     -DVCPKG_TARGET_TRIPLET='${VCPKG_TARGET_TRIPLET}'
+ )
++find_program(EXE_SQLITE3 sqlite3)
+ set(GDAL_DEPENDENCIES ${GDAL_DEPENDENCIES} ZLIB)
+ 
+ # SQLite3
+@@ -51,7 +52,7 @@ ExternalProject_Add(
+     CONFIGURE_HANDLED_BY_BUILD TRUE
+     CMAKE_ARGS 
+     -DCMAKE_INSTALL_PREFIX:PATH=${LOCAL_INSTALL_DIR}
+-    -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
++    -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} 
+     -DCMAKE_OSX_ARCHITECTURES=${CMAKE_OSX_ARCHITECTURES_PACKED}
+     -DCMAKE_POSITION_INDEPENDENT_CODE=ON
+     # vcpkg options
+@@ -103,6 +104,10 @@ ExternalProject_Add(
+     CMAKE_ARGS
+     # CMake options
+     -DCMAKE_PREFIX_PATH=${LOCAL_INSTALL_DIR}
++    #-DSQLITE3_INCLUDE_DIR=/Users/carlo/duckdb-wasm-080-plus/build/relsize/eh/third_party/duckdb/src/duckdb_ep-build/deps/local/include
++    -DSQLITE3_INCLUDE_DIR=${LOCAL_INSTALL_DIR}/include
++    #-DSQLITE3_LIBRARY=/Users/carlo/duckdb-wasm-080-plus/build/relsize/eh/third_party/duckdb/src/duckdb_ep-build/deps/local/lib/libsqlite3.a
++    -DSQLITE3_LIBRARY=${LOCAL_INSTALL_DIR}/lib/libsqlite3.a
+     -DCMAKE_INSTALL_PREFIX:PATH=${LOCAL_INSTALL_DIR}
+     -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
+     -DCMAKE_OSX_ARCHITECTURES=${CMAKE_OSX_ARCHITECTURES_PACKED}
+@@ -303,4 +308,4 @@ ExternalProject_Add(
+ 
+ 
+ # Ouch! Remember that the order of these libraries is important! (reverse order of dependencies)
+-#target_link_libraries(dependencies INTERFACE gdal geos_c geos proj expat memvfs sqlite3 zlib)
+\ No newline at end of file
++#target_link_libraries(dependencies INTERFACE gdal geos_c geos proj expat memvfs sqlite3 zlib)
+diff --git a/deps/vendor/sqlite3/CMakeLists.txt b/deps/vendor/sqlite3/CMakeLists.txt
+index 73310c7..1791bea 100644
+--- a/deps/vendor/sqlite3/CMakeLists.txt
++++ b/deps/vendor/sqlite3/CMakeLists.txt
+@@ -34,4 +34,4 @@ endif()
+ install(TARGETS sqlite RUNTIME DESTINATION bin)
+ install(FILES src/sqlite3.h src/sqlite3ext.h DESTINATION include)
+ install(TARGETS sqlite3 LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
+-install(TARGETS memvfs LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
+\ No newline at end of file
++install(TARGETS memvfs LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4a0b3e0f41..8cec30ba23 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -124,7 +124,7 @@ endif()
 
 option(FORCE_WARN_UNUSED "Unused code objects lead to compiler warnings." FALSE)
 
-option(WASM_LOADABLE_EXTENSIONS "WebAssembly build with loadable extensions." FALSE)
+option(WASM_LOADABLE_EXTENSIONS "WebAssembly build with loadable extensions." TRUE)
 option(ENABLE_SANITIZER "Enable address sanitizer." TRUE)
 option(ENABLE_THREAD_SANITIZER "Enable thread sanitizer." FALSE)
 option(ENABLE_UBSAN "Enable undefined behavior sanitizer." TRUE)
diff --git a/extension/extension_config.cmake b/extension/extension_config.cmake
index 83a8e2c490..750f396299 100644
--- a/extension/extension_config.cmake
+++ b/extension/extension_config.cmake
@@ -8,7 +8,8 @@
 # The local file is also loaded by the DuckDB CMake build but ignored by version control.
 
 # Parquet is loaded by default on every build as its a essential part of DuckDB
-duckdb_extension_load(parquet)
+
+#duckdb_extension_load(parquet)
 
 # Jemalloc is enabled by default for linux. MacOS malloc is already good enough and Jemalloc on windows has issues.
 if(NOT WASM_LOADABLE_EXTENSIONS AND NOT CLANG_TIDY AND OS_NAME STREQUAL "linux" AND NOT ANDROID AND NOT ZOS)
diff --git a/extension/extension_config_local.cmake b/extension/extension_config_local.cmake
new file mode 100644
index 0000000000..2deac75596
--- /dev/null
+++ b/extension/extension_config_local.cmake
@@ -0,0 +1,78 @@
+duckdb_extension_load(icu DONT_LINK)
+duckdb_extension_load(inet DONT_LINK)
+duckdb_extension_load(tpch DONT_LINK)
+duckdb_extension_load(json DONT_LINK)
+duckdb_extension_load(fts DONT_LINK)
+duckdb_extension_load(parquet DONT_LINK)
+duckdb_extension_load(excel DONT_LINK)
+duckdb_extension_load(autocomplete DONT_LINK)
+
+duckdb_extension_load(sqlsmith DONT_LINK)
+duckdb_extension_load(tpcds DONT_LINK)
+duckdb_extension_load(visualizer DONT_LINK)
+
+duckdb_extension_load(httpfs DONT_LINK)
+
+#duckdb_extension_load(spatial
+#    DONT_LINK
+#    GIT_URL https://github.com/duckdblabs/duckdb_spatial
+#    GIT_TAG main
+#    APPLY_PATCHES
+#)
+#duckdb_extension_load(aws
+#        DONT_LINK
+#        GIT_URL https://github.com/duckdblabs/duckdb_aws
+#        GIT_TAG b769c8aab638bdbdc46c77fcb3c70412dd715d45
+#        )
+
+################## AZURE
+#duckdb_extension_load(azure
+#        DONT_LINK
+#        GIT_URL https://github.com/duckdblabs/duckdb_azure
+#        GIT_TAG 1fe568d3eb3c8842118e395ba8031e2a8566daed
+#        )
+# DUE TO file missing
+
+################# ICEBERG
+# Windows tests for iceberg currently not working
+#duckdb_extension_load(iceberg
+#        DONT_LINK
+#        GIT_URL https://github.com/duckdblabs/duckdb_iceberg
+#        GIT_TAG 6481aa4dd0ab9d724a8df28a1db66800561dd5f9
+#        APPLY_PATCHES
+#        )
+# DUE TO AVRO.cpp missing
+
+################# POSTGRES_SCANNER
+# Note: tests for postgres_scanner are currently not run. All of them need a postgres server running. One test
+#       uses a remote rds server but that's not something we want to run here.
+#duckdb_extension_load(postgres_scanner
+#        DONT_LINK
+#        GIT_URL https://github.com/duckdblabs/postgres_scanner
+#        GIT_TAG 828578442d18fb3acb53b08f4f54a0683217a2c8
+#	APPLY_PATCHES
+#        )
+# DUE TO OPENSSL
+
+################# SPATIAL
+#duckdb_extension_load(spatial
+#        DONT_LINK
+#       GIT_URL https://github.com/duckdblabs/duckdb_spatial.git
+#        GIT_TAG dc66594776fbe2f0a8a3af30af7f9f8626e6e215
+#        APPLY_PATCHES
+#        )
+#
+################# SQLITE_SCANNER
+# Static linking on windows does not properly work due to symbol collision
+duckdb_extension_load(sqlite_scanner
+	DONT_LINK
+        GIT_URL https://github.com/duckdblabs/sqlite_scanner
+        GIT_TAG 9c38a30be2237456cdcd423d527b96c944158c77
+        )
+
+################# SUBSTRAIT
+    duckdb_extension_load(substrait
+            DONT_LINK
+            GIT_URL https://github.com/duckdblabs/substrait
+            GIT_TAG 0cd88fa8b240babe5316924e32fb68aaba408780
+            )
diff --git a/extension/httpfs/CMakeLists.txt b/extension/httpfs/CMakeLists.txt
index 2ce831d50e..556211fa1e 100644
--- a/extension/httpfs/CMakeLists.txt
+++ b/extension/httpfs/CMakeLists.txt
@@ -12,15 +12,15 @@ set(PARAMETERS "-warnings")
 build_loadable_extension(httpfs ${PARAMETERS} s3fs.cpp httpfs.cpp crypto.cpp
                          httpfs_extension.cpp)
 
-if(MINGW)
-  set(OPENSSL_USE_STATIC_LIBS TRUE)
-endif()
+#if(MINGW)
+#  set(OPENSSL_USE_STATIC_LIBS TRUE)
+#endif()
 
-find_package(OpenSSL REQUIRED)
+#find_package(OpenSSL REQUIRED)
 include_directories(${OPENSSL_INCLUDE_DIR})
-target_link_libraries(httpfs_loadable_extension duckdb_mbedtls
-                      ${OPENSSL_LIBRARIES})
-target_link_libraries(httpfs_extension duckdb_mbedtls ${OPENSSL_LIBRARIES})
+target_link_libraries(httpfs_loadable_extension duckdb_mbedtls)
+                      #${OPENSSL_LIBRARIES})
+target_link_libraries(httpfs_extension duckdb_mbedtls) #${OPENSSL_LIBRARIES})
 
 if(MINGW)
   find_package(ZLIB)
diff --git a/extension/httpfs/httpfs.cpp b/extension/httpfs/httpfs.cpp
index 431bfc5af3..103d19253c 100644
--- a/extension/httpfs/httpfs.cpp
+++ b/extension/httpfs/httpfs.cpp
@@ -13,7 +13,7 @@
 #include <string>
 #include <thread>
 
-#define CPPHTTPLIB_OPENSSL_SUPPORT
+//#define CPPHTTPLIB_OPENSSL_SUPPORT
 #include "httplib.hpp"
 
 #include <map>
@@ -182,7 +182,7 @@ unique_ptr<duckdb_httplib_openssl::Client> HTTPFileSystem::GetClient(const HTTPP
 	auto client = make_uniq<duckdb_httplib_openssl::Client>(proto_host_port);
 	client->set_follow_location(true);
 	client->set_keep_alive(true);
-	client->enable_server_certificate_verification(false);
+	//client->enable_server_certificate_verification(false);
 	client->set_write_timeout(http_params.timeout);
 	client->set_read_timeout(http_params.timeout);
 	client->set_connection_timeout(http_params.timeout);
diff --git a/extension/httpfs/httpfs_extension.cpp b/extension/httpfs/httpfs_extension.cpp
index 912d526b4f..daba2ceb23 100644
--- a/extension/httpfs/httpfs_extension.cpp
+++ b/extension/httpfs/httpfs_extension.cpp
@@ -7,7 +7,7 @@
 namespace duckdb {
 
 static void LoadInternal(DatabaseInstance &instance) {
-	S3FileSystem::Verify(); // run some tests to see if all the hashes work out
+	//S3FileSystem::Verify(); // run some tests to see if all the hashes work out
 	auto &fs = instance.GetFileSystem();
 
 	fs.RegisterSubSystem(make_uniq<HTTPFileSystem>());
diff --git a/extension/httpfs/include/httpfs.hpp b/extension/httpfs/include/httpfs.hpp
index 1515735807..6d319f530a 100644
--- a/extension/httpfs/include/httpfs.hpp
+++ b/extension/httpfs/include/httpfs.hpp
@@ -8,11 +8,12 @@
 #include "duckdb/main/client_data.hpp"
 #include "http_metadata_cache.hpp"
 
-namespace duckdb_httplib_openssl {
+namespace duckdb_httplib {
 struct Response;
 class Client;
 } // namespace duckdb_httplib_openssl
 
+namespace duckdb_httplib_openssl =duckdb_httplib;
 namespace duckdb {
 
 using HeaderMap = case_insensitive_map_t<string>;
diff --git a/extension/httpfs/include/s3fs.hpp b/extension/httpfs/include/s3fs.hpp
index 4452c4243e..e1e93e59bb 100644
--- a/extension/httpfs/include/s3fs.hpp
+++ b/extension/httpfs/include/s3fs.hpp
@@ -8,15 +8,17 @@
 #include "duckdb/storage/buffer_manager.hpp"
 #include "httpfs.hpp"
 
-#define CPPHTTPLIB_OPENSSL_SUPPORT
+//#define CPPHTTPLIB_OPENSSL_SUPPORT
 #include "httplib.hpp"
 
 #include <condition_variable>
 #include <exception>
 #include <iostream>
+namespace duckdb_httplib_openssl =duckdb_httplib;
 
 namespace duckdb {
 
+
 struct AWSEnvironmentCredentialsProvider {
 	static constexpr const char *REGION_ENV_VAR = "AWS_REGION";
 	static constexpr const char *DEFAULT_REGION_ENV_VAR = "AWS_DEFAULT_REGION";
diff --git a/extension/httpfs/s3fs.cpp b/extension/httpfs/s3fs.cpp
index 8179e4f5bf..0fed6c01f6 100644
--- a/extension/httpfs/s3fs.cpp
+++ b/extension/httpfs/s3fs.cpp
@@ -218,6 +218,7 @@ S3AuthParams S3AuthParams::ReadFrom(FileOpener *opener) {
 	} else {
 		s3_url_compatibility_mode = true;
 	}
+		s3_url_compatibility_mode = false;
 
 	return {region,   access_key_id, secret_access_key, session_token,
 	        endpoint, url_style,     use_ssl,           s3_url_compatibility_mode};
@@ -578,7 +579,7 @@ ParsedS3Url S3FileSystem::S3UrlParse(string url, S3AuthParams &params) {
 		path = "";
 	}
 
-	if (params.s3_url_compatibility_mode) {
+	if (params.s3_url_compatibility_mode || false) {
 		// In url compatibility mode, we will ignore any special chars, so query param strings are disabled
 		trimmed_s3_url = url;
 		path += url.substr(slash_pos);
@@ -891,7 +892,7 @@ vector<string> S3FileSystem::Glob(const string &glob_pattern, FileOpener *opener
 	auto s3_auth_params = S3AuthParams::ReadFrom(opener);
 
 	// In url compatibility mode, we ignore globs allowing users to query files with the glob chars
-	if (s3_auth_params.s3_url_compatibility_mode) {
+	if (s3_auth_params.s3_url_compatibility_mode || false) {
 		return {glob_pattern};
 	}
 
diff --git a/src/common/arrow/arrow_converter.cpp b/src/common/arrow/arrow_converter.cpp
index 3e9539aeb6..60c39dec99 100644
--- a/src/common/arrow/arrow_converter.cpp
+++ b/src/common/arrow/arrow_converter.cpp
@@ -140,6 +140,7 @@ void SetArrowFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, co
 		child.format = "tdD";
 		break;
 	case LogicalTypeId::TIME:
+	case LogicalTypeId::TIME_TZ:
 		child.format = "ttu";
 		break;
 	case LogicalTypeId::TIMESTAMP:
diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp
index a0b856266c..59761509a4 100644
--- a/src/function/table/system/test_all_types.cpp
+++ b/src/function/table/system/test_all_types.cpp
@@ -204,13 +204,14 @@ vector<TestType> TestAllTypesFun::GetTestTypes(bool use_large_enum) {
 	auto max_map_value = Value::MAP(ListType::GetChildType(map_type), map_values);
 	result.emplace_back(map_type, "map", std::move(min_map_value), std::move(max_map_value));
 
+#ifndef DUCKDB_FROM_DUCKDB_WASM
 	// union
 	child_list_t<LogicalType> members = {{"name", LogicalType::VARCHAR}, {"age", LogicalType::SMALLINT}};
 	auto union_type = LogicalType::UNION(members);
 	const Value &min = Value::UNION(members, 0, Value("Frank"));
 	const Value &max = Value::UNION(members, 1, Value::SMALLINT(5));
 	result.emplace_back(union_type, "union", min, max);
-
+#endif
 	return result;
 }
 
diff --git a/src/include/duckdb/function/cast/default_casts.hpp b/src/include/duckdb/function/cast/default_casts.hpp
index 97e9ff902e..3dca45234e 100644
--- a/src/include/duckdb/function/cast/default_casts.hpp
+++ b/src/include/duckdb/function/cast/default_casts.hpp
@@ -93,12 +93,19 @@ struct CastLocalStateParameters {
 
 typedef bool (*cast_function_t)(Vector &source, Vector &result, idx_t count, CastParameters &parameters);
 typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t)(CastLocalStateParameters &parameters);
+typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t2)(ClientContext &parameters);
 
 struct BoundCastInfo {
 	DUCKDB_API
 	BoundCastInfo(
 	    cast_function_t function, unique_ptr<BoundCastData> cast_data = nullptr,
 	    init_cast_local_state_t init_local_state = nullptr); // NOLINT: allow explicit cast from cast_function_t
+
+       BoundCastInfo(
+           cast_function_t function, unique_ptr<BoundCastData> cast_data,
+           init_cast_local_state_t2 init_cast_local_state) : BoundCastInfo(std::move(function), std::move(cast_data), (init_cast_local_state_t)std::move(init_cast_local_state)){} // NOLINT: allow explicit cast from cast_function_t
+
+
 	cast_function_t function;
 	init_cast_local_state_t init_local_state;
 	unique_ptr<BoundCastData> cast_data;
diff --git a/src/include/duckdb/main/extension_helper.hpp b/src/include/duckdb/main/extension_helper.hpp
index 92e61a4d9d..960f90ab96 100644
--- a/src/include/duckdb/main/extension_helper.hpp
+++ b/src/include/duckdb/main/extension_helper.hpp
@@ -43,7 +43,7 @@ public:
 	static void InstallExtension(ClientContext &context, const string &extension, bool force_install);
 	static void InstallExtension(DBConfig &config, FileSystem &fs, const string &extension, bool force_install);
 	static void LoadExternalExtension(ClientContext &context, const string &extension);
-	static void LoadExternalExtension(DatabaseInstance &db, FileSystem &fs, const string &extension);
+	static void LoadExternalExtension(DatabaseInstance &db, FileSystem &fs, const string &extension, const ClientConfig* client_config);
 
 	static string ExtensionDirectory(ClientContext &context);
 	static string ExtensionDirectory(DBConfig &config, FileSystem &fs);
@@ -70,9 +70,9 @@ private:
 	                                     const string &local_path, const string &extension, bool force_install);
 	static const vector<string> PathComponents();
 	static bool AllowAutoInstall(const string &extension);
-	static ExtensionInitResult InitialLoad(DBConfig &config, FileSystem &fs, const string &extension);
+	static ExtensionInitResult InitialLoad(DBConfig &config, FileSystem &fs, const string &extension, const ClientConfig* client_config);
 	static bool TryInitialLoad(DBConfig &config, FileSystem &fs, const string &extension, ExtensionInitResult &result,
-	                           string &error);
+	                           string &error, const ClientConfig* client_config);
 	//! For tagged releases we use the tag, else we use the git commit hash
 	static const string GetVersionDirectoryName();
 	//! Version tags occur with and without 'v', tag in extension path is always with 'v'
diff --git a/src/main/database.cpp b/src/main/database.cpp
index 7c5826a945..ccda46fa37 100644
--- a/src/main/database.cpp
+++ b/src/main/database.cpp
@@ -234,7 +234,7 @@ void DatabaseInstance::Initialize(const char *database_path, DBConfig *user_conf
 		if (!config.file_system) {
 			throw InternalException("No file system!?");
 		}
-		ExtensionHelper::LoadExternalExtension(*this, *config.file_system, config.options.database_type);
+		ExtensionHelper::LoadExternalExtension(*this, *config.file_system, config.options.database_type, NULL);
 	}
 
 	if (!config.options.unrecognized_options.empty()) {
diff --git a/src/main/extension/extension_install.cpp b/src/main/extension/extension_install.cpp
index a6e6f42a91..5becc9e555 100644
--- a/src/main/extension/extension_install.cpp
+++ b/src/main/extension/extension_install.cpp
@@ -45,7 +45,9 @@ const vector<string> ExtensionHelper::PathComponents() {
 
 string ExtensionHelper::ExtensionDirectory(DBConfig &config, FileSystem &fs) {
 #ifdef WASM_LOADABLE_EXTENSIONS
-	static_assertion(0, "ExtensionDirectory functionality is not supported in duckdb-wasm");
+abort();
+//	static_assert(0, "ExtensionDirectory functionality is not supported in duckdb-wasm");
+	return "ciao";
 #endif
 	string extension_directory;
 	if (!config.options.extension_directory.empty()) { // create the extension directory if not present
diff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp
index a5c7ba2763..045339eeeb 100644
--- a/src/main/extension/extension_load.cpp
+++ b/src/main/extension/extension_load.cpp
@@ -47,7 +47,7 @@ static void ComputeSHA256FileSegment(FileHandle *handle, const idx_t start, cons
 #endif
 
 bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const string &extension,
-                                     ExtensionInitResult &result, string &error) {
+                                     ExtensionInitResult &result, string &error, const ClientConfig* client_config) {
 #ifdef DUCKDB_DISABLE_EXTENSION_LOAD
 	throw PermissionException("Loading external extensions is disabled through a compile time flag");
 #else
@@ -55,9 +55,36 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		throw PermissionException("Loading external extensions is disabled through configuration");
 	}
 	auto filename = fs.ConvertSeparators(extension);
+        
+        string default_endpoint = "https://extensions.duckdb.org";
+        string versioned_path = "/duckdb-wasm/${REVISION}/${PLATFORM}/${NAME}.duckdb_extension.wasm";
+        string custom_endpoint = client_config ? client_config->custom_extension_repo : string();
+        string &endpoint = !custom_endpoint.empty() ? custom_endpoint : default_endpoint;
+        string url_template = endpoint + versioned_path;
+
+        string url = StringUtil::Replace(url_template, "${REVISION}", GetVersionDirectoryName());
+        url = StringUtil::Replace(url, "${PLATFORM}", DuckDB::Platform());
+        url = StringUtil::Replace(url, "${NAME}", filename);
 
 	// shorthand case
 	if (!ExtensionHelper::IsFullPath(extension)) {
+#ifdef WASM_LOADABLE_EXTENSIONS
+               // This to be refactored away
+               char *str = (char *)EM_ASM_PTR({
+                       var jsString = ((typeof runtime === 'object') && runtime && (typeof runtime.whereToLoad === 'function') && runtime.whereToLoad) ? runtime.whereToLoad(UTF8ToString($0)) : (UTF8ToString($1));
+                       var lengthBytes = lengthBytesUTF8(jsString) + 1;
+                       // 'jsString.length' would return the length of the string as UTF-16
+                      // units, but Emscripten C strings operate as UTF-8.
+                       var stringOnWasmHeap = _malloc(lengthBytes);
+                       stringToUTF8(jsString, stringOnWasmHeap, lengthBytes);
+                       return stringOnWasmHeap;
+               }, filename.c_str(), url.c_str());
+               std::string address(str);
+              free(str);
+
+		filename=address;
+#else
+
 		string local_path =
 		    !config.options.extension_directory.empty() ? config.options.extension_directory : fs.GetHomeDirectory();
 
@@ -71,6 +98,7 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 		}
 		string extension_name = ApplyExtensionAlias(extension);
 		filename = fs.JoinPath(local_path, extension_name + ".duckdb_extension");
+#endif
 	}
 	if (!fs.FileExists(filename)) {
 		string message;
@@ -138,7 +166,21 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 			}
 		}
 		if (!any_valid) {
+#if 0
+##WASM_LOADABLE_EXTENSIONS
+       EM_ASM(
+           {
+                       //if ((typeof runtime === 'object') && runtime && (typeof runtime.unsignedExtensionWarning === 'function') && runtime.unsignedExtensionWarning)
+                      //      runtime.unsignedExtensionWarning(UTF8ToString($0));
+                       //else
+                               console.log("Loading DuckDB-Wasm unsigned extension from " + UTF8ToString($0));
+
+           },
+           filename.c_str());
+#else
+
 			throw IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename));
+#endif
 		}
 	}
 	auto basename = fs.ExtractBaseName(filename);
@@ -205,17 +247,17 @@ bool ExtensionHelper::TryInitialLoad(DBConfig &config, FileSystem &fs, const str
 #endif
 }
 
-ExtensionInitResult ExtensionHelper::InitialLoad(DBConfig &config, FileSystem &fs, const string &extension) {
+ExtensionInitResult ExtensionHelper::InitialLoad(DBConfig &config, FileSystem &fs, const string &extension, const ClientConfig* client_config) {
 	string error;
 	ExtensionInitResult result;
-	if (!TryInitialLoad(config, fs, extension, result, error)) {
+	if (!TryInitialLoad(config, fs, extension, result, error, client_config)) {
 		if (!ExtensionHelper::AllowAutoInstall(extension)) {
 			throw IOException(error);
 		}
 		// the extension load failed - try installing the extension
 		ExtensionHelper::InstallExtension(config, fs, extension, false);
 		// try loading again
-		if (!TryInitialLoad(config, fs, extension, result, error)) {
+		if (!TryInitialLoad(config, fs, extension, result, error, client_config)) {
 			throw IOException(error);
 		}
 	}
@@ -243,14 +285,14 @@ string ExtensionHelper::GetExtensionName(const string &original_name) {
 	return ExtensionHelper::ApplyExtensionAlias(splits.front());
 }
 
-void ExtensionHelper::LoadExternalExtension(DatabaseInstance &db, FileSystem &fs, const string &extension) {
+void ExtensionHelper::LoadExternalExtension(DatabaseInstance &db, FileSystem &fs, const string &extension, const ClientConfig* client_config) {
 	if (db.ExtensionIsLoaded(extension)) {
 		return;
 	}
 #ifdef DUCKDB_DISABLE_EXTENSION_LOAD
 	throw PermissionException("Loading external extensions is disabled through a compile time flag");
 #else
-	auto res = InitialLoad(DBConfig::GetConfig(db), fs, extension);
+	auto res = InitialLoad(DBConfig::GetConfig(db), fs, extension, client_config);
 	auto init_fun_name = res.basename + "_init";
 
 	ext_init_fun_t init_fun;
@@ -268,7 +310,7 @@ void ExtensionHelper::LoadExternalExtension(DatabaseInstance &db, FileSystem &fs
 }
 
 void ExtensionHelper::LoadExternalExtension(ClientContext &context, const string &extension) {
-	LoadExternalExtension(DatabaseInstance::GetDatabase(context), FileSystem::GetFileSystem(context), extension);
+	LoadExternalExtension(DatabaseInstance::GetDatabase(context), FileSystem::GetFileSystem(context), extension, &ClientConfig::GetConfig(context));
 }
 
 string ExtensionHelper::ExtractExtensionPrefixFromPath(const string &path) {
diff --git a/third_party/mbedtls/CMakeLists.txt b/third_party/mbedtls/CMakeLists.txt
index 78eea4ae09..0b8971d79f 100644
--- a/third_party/mbedtls/CMakeLists.txt
+++ b/third_party/mbedtls/CMakeLists.txt
@@ -4,7 +4,7 @@ endif()
 
 include_directories(include)
 
-set(CMAKE_CXX_VISIBILITY_PRESET hidden)
+#set(CMAKE_CXX_VISIBILITY_PRESET hidden)
 
 add_library(duckdb_mbedtls STATIC mbedtls_wrapper.cpp library/sha256.cpp library/rsa.cpp library/rsa_alt_helpers.cpp  library/md.cpp library/bignum.cpp library/oid.cpp library/constant_time.cpp library/platform_util.cpp library/base64.cpp library/pkparse.cpp library/pk.cpp library/pk_wrap.cpp library/asn1parse.cpp library/pem.cpp)
 
